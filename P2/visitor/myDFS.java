//
// Generated by JTB 1.3.2
//
package visitor;
import syntaxtree.*;
import java.util.*;
/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
class FunctionTable
{
  Hashtable<String,String> arguments = new Hashtable<String,String>();
  String return_type;
  Hashtable<String,String> variables = new Hashtable<String,String>();
  Hashtable<Integer,String> type_inorder = new Hashtable<Integer,String>();
}

class ClassTable
{
  Hashtable<String,String> fields = new Hashtable<String,String>();
  Hashtable<String,FunctionTable> functions = new Hashtable<String,FunctionTable>();
  String parent;//which class does it inherit from?
}

public class myDFS<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
    Hashtable<String,ClassTable> classes = new Hashtable<String,ClassTable>();
    ArrayList<String> message_arguments = new ArrayList<String>();
    Hashtable<String,String> parent_class = new Hashtable<String,String>();
    //Hashtable<String,String> variable_type = new Hashtable<String,String>();//stores variables and their type in the current scope as a hashmap
    int argument_index;
    String current_class;
    String current_method = null;
    ClassTable class_object;
    FunctionTable function_object;
    public boolean debug = false;
    String this_class;
    public void helper()
    {
      Set<String> Classes = classes.keySet();
      Iterator<String> itr = Classes.iterator();
      while(itr.hasNext())
      {
        String class_name = itr.next();
        System.out.println("Class " + class_name + ":");
        ClassTable ct = classes.get(class_name);
        System.out.println("Fields are as follows:");
        Set<String> fields = ct.fields.keySet();
        Iterator<String> itr1 = fields.iterator();
        while(itr1.hasNext())
        {
          String t = itr1.next();
          System.out.println(t + ":" + ct.fields.get(t));
        }
        Set<String> fns = ct.functions.keySet();
        Iterator<String> itr2 = fns.iterator();
        while(itr2.hasNext())
        {
          String function_name = itr2.next();
          System.out.println("Function " + function_name + ":");
          FunctionTable func = ct.functions.get(function_name);
          Set<String> args = func.arguments.keySet();
          Iterator<String> itr3 = args.iterator();
          System.out.println("Arguments are: ");
          while(itr3.hasNext())
          {
            String argum = itr3.next();
            System.out.println(argum + ": " + func.arguments.get(argum));
          }
          args = func.variables.keySet();
          itr3 = args.iterator();
          System.out.println("Variables are: ");
          while(itr3.hasNext())
          {
            String argum = itr3.next();
            System.out.println(argum + ": " + func.variables.get(argum));
          }
          System.out.println("Return type: " + func.return_type);
        }
        System.out.println("This class inherits from " + ct.parent);
        System.out.println("*************************");
      }
    }
    public void error_message(String error_msg, String flag)
    {
      System.out.println(error_msg);
      if(debug)
      {
        System.out.println(flag);
        System.out.println(current_class + ":" + current_method);
      }
      System.exit(0);
    }
    public String get_type(String id)
    {
      if(id.equals("int") || id.equals("boolean") || id.equals("int[]"))
        return id;
      else if(id.equals("this"))
      {
        //System.out.println(this_class + " " + current_class + " " + current_method);
        return current_class;//type would be whichever object is currently active. Search in this space for the appropriate identifier.
      }
      else if(classes.get(id) != null)
      {
        String t1 = function_object.arguments.get(id);
        String t2 = function_object.variables.get(id);
        //may be of type object or may even be an identifier having a name same as that of a User defined datatype
        if(t1 == null && t2 == null)
        {
          String t = current_class;
          while(t != null)
          {
            if(classes.get(t) == null)
            {
              String error_msg = "Symbol not found"; 
              String flag = "Undefined Class"; 
              error_message(error_msg,flag);
            }
            String ty = classes.get(t).fields.get(id);
            if(ty != null)
              return ty;
            t = classes.get(t).parent;
          }
          return id;//type in itself
        }
        else
          return (t1 == null)?t1:t2;
      }
      String t1 = (function_object == null)?null:function_object.arguments.get(id);
      String t2 = (function_object == null)?null:function_object.variables.get(id);
      if(t1 != null)
        return t1;
      if(t2 != null)
        return t2;
      String t = current_class;
      while(t != null)
      {
        String ty = classes.get(t).fields.get(id);
        if(ty != null)
          return ty;
        t = classes.get(t).parent;
      }
      String error_msg = "Symbol not found";//or is it a type error?
      String flag = "undeclared type";
      error_message(error_msg,flag);
      return null;
    }
    public boolean type_check(String t1, String t2)
    {
      t1 = get_type(t1);
      t2 = get_type(t2);
      //System.out.println(t1 + " " + t2);
      if(t1.equals("void") || t2.equals("void"))
      {
        String error_msg = "Type error"; 
        String flag = "void type" + t1 + " " + t2; 
        error_message(error_msg,flag);
      }
      boolean y1 = t1.equals("int")||t1.equals("boolean")||t1.equals("int[]");
      boolean y2 = t2.equals("int")||t2.equals("boolean")||t2.equals("int[]");
      boolean x1 = (y1 == y2);
      if(x1)
      {
        if(y1)
          return t1.equals(t2);
        else
        {
          //t2's ancestor should be t1
          boolean fl = false;
          while(t2 != null)
          {
            if(t1.equals(t2))
            {
              fl = true;
              break;
            }
            t2 = classes.get(t2).parent;
          }
          return fl;
        }
      }
      else
        return false;
    }
    public boolean check_parent(String id)
    {
      boolean fl = false;
      String t = current_class;
      while(t != null)
      {
        if(classes.get(t) == null)
        {
          String error_msg = "Symbol not found"; 
          String flag = "Undefined class"; 
          error_message(error_msg,flag);
        }
        if(classes.get(t).fields.get(id) != null)
        {
          fl = true;
          break;
        }
        t = classes.get(t).parent;
      }
      return fl;
    }
    public String get_function(String id,int num_args,int old_size)
    {
      String t = this_class;
      boolean x = false;
      while(t != null)
      {
        FunctionTable fn = classes.get(t).functions.get(id);
        t = classes.get(t).parent;
        if(fn == null)
          continue;
        if(fn.arguments.size() != num_args)
        {
          x = true;
          continue;
        }
        boolean fl = true;
        for(int i = 0;i < num_args;i++)
        {
          String t2 = message_arguments.get(i+old_size);
          String t1 = fn.type_inorder.get(i);
          if(!type_check(t1,t2))
          {
            fl = false;
            break;
          } 
        }
        if(fl)
          return fn.return_type;
        else
        {
          continue;
        }
      }
      if(x)
      {
        String error_msg = "Type error";
        String flag = "Function exists but did not match.";
        error_message(error_msg,flag);
      }
      return null;
    }
    public void check_function()
    {
      //check if there are any overriding errors
      String t = classes.get(current_class).parent;
      while(t != null)
      {
        FunctionTable f = classes.get(t).functions.get(current_method);
        if(f != null)
        {
          if(f.arguments.size() != function_object.arguments.size())
          {
            String error_msg = "Type error";
            String flag = "Function overloading in the parent class is not allowed";
            error_message(error_msg,flag);
          }
          boolean fl = false;
          for(int i = 0;i < f.arguments.size();i++)
          {
            if(!type_check(f.type_inorder.get(i),function_object.type_inorder.get(i)))
            {
              fl = true;
              break;
            }
          }
          if(fl)
          {
            String error_msg = "Type error";
            String flag = "Function overloading in the parent class is not allowed";
            error_message(error_msg,flag);
          }
          if(!type_check(f.return_type,function_object.return_type))
          {
            String error_msg = "Type error";
            String flag = "Overriding not allowed, because return type cannot differ.";
            error_message(error_msg,flag);
          }
          else
          {
            return;//overriding is legally allowed now.
          }
        }
        t = classes.get(t).parent;
      }
      return;//overriding does not apply since there are no functions of the same name
    }
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String class_name = (String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      String arg_name = (String)n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)
      {
        //first pass add it into the symbol table
        if(classes.get(class_name) != null)
        {
          String error_msg = "Type error"; 
          String flag = "redeclaration of Main Class"; 
          error_message(error_msg,flag);
        }
        ClassTable obj = new ClassTable();
        obj.parent = null;
        obj.fields = new Hashtable<String,String>();
        FunctionTable obj1 = new FunctionTable();
        obj1.return_type = "void";
        obj1.arguments.put(arg_name,"String[]");
        obj.functions.put("main",obj1);
        classes.put(class_name,obj);
      }
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) {
      R _ret=null;
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)//first pass is enough to build symbol table
      {
        n.f0.accept(this, argu);
        String class_name = (String)n.f1.accept(this, argu);
        if(classes.get(class_name) != null)
        {
          String error_msg = "Type error"; 
          String flag = "Redeclaration of Class"; 
          error_message(error_msg,flag);
        }
        class_object = new ClassTable();
        class_object.parent = null; 
        current_class = class_name;
        n.f2.accept(this, argu);
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        n.f5.accept(this, argu);
        classes.put(class_name,class_object);
      }
      else
      {
        //type check each function nows
        n.f0.accept(this,argu);
        current_class = (String)n.f1.accept(this,argu);
        class_object = classes.get(current_class);
        n.f2.accept(this,argu);
        n.f3.accept(this,argu);
        n.f4.accept(this,argu);
        n.f5.accept(this,argu);
      }
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) 
   {
      R _ret=null;
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)
      {
        n.f0.accept(this, argu);
        String class_name = (String)n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        if(classes.get(class_name) != null)
        {
          String error_msg = "Type error"; 
          String flag = "Redeclaration of extends Class"; 
          error_message(error_msg,flag);
        }
        current_class = class_name;
        class_object = new ClassTable();
        String parent_name = (String)n.f3.accept(this, argu);
        String t = parent_name;
        boolean fl = false;
        while(t != null)
        {
          if(t.equals(class_name))
          {
            fl = true;
            break;
          }
          t = parent_class.get(t);
        }
        if(fl)
        {
          String error_msg = "Type error"; 
          String flag = "Cyclic Inheritance"; 
          error_message(error_msg,flag);
        }
        parent_class.put(class_name,parent_name);//update
        class_object.parent = parent_name;
        n.f4.accept(this, argu);
        n.f5.accept(this, argu);
        n.f6.accept(this, argu);
        n.f7.accept(this, argu);
        classes.put(class_name,class_object);
      }
      else
      {
        //type check now
        n.f0.accept(this,argu);
        current_class = (String)n.f1.accept(this,argu);
        n.f2.accept(this,argu);
        String base = (String)n.f3.accept(this,argu);
        if(classes.get(base) == null)
        {
          String error_msg = "Symbol not found"; 
          String flag = "undeclared class"; 
          error_message(error_msg,flag);
        }
        class_object = classes.get(current_class);
        n.f4.accept(this,argu);
        n.f5.accept(this,argu);
        n.f6.accept(this,argu);
        n.f7.accept(this,argu);
      }
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) {
      R _ret=null;
      String var_type = (String)n.f0.accept(this, argu);
      String var_name = (String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)
      {
        if(current_method == null)
        {
          if(class_object.fields.get(var_name) != null)
          {
            String error_msg = "Type error"; 
            String flag = "Redeclaration of class variable shadowing earlier definition"; 
            error_message(error_msg,flag);//redeclaration of variable is not allowed
          }
          class_object.fields.put(var_name,var_type);
        }
        else
        {
          if(function_object.arguments.get(var_name) != null)
          {
            String error_msg = "Type error"; 
            String flag = "Declaration of function variable shadows function parameter"; 
            error_message(error_msg,flag);
          }
          function_object.variables.put(var_name,var_type);//shadow class declaration
        }
      }
      else
      {
        //check if the type is actually present in the program
        if(var_type.equals("int") || var_type.equals("boolean") || var_type.equals("int[]") || (classes.get(var_type) != null))
        {
          return _ret;
        }
        else
        {
          String error_msg = "Symbol not found"; 
          String flag = "Undefined type for type declaration"; 
          error_message(error_msg,flag);
        }
        return _ret;
      }
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) {
      R _ret=null;
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)
      {
        n.f0.accept(this, argu);
        String return_type = (String)n.f1.accept(this, argu);
        String function_name = (String)n.f2.accept(this, argu);
        if(class_object.functions.get(function_name) != null)
        {
          String error_msg = "Type error"; 
          String flag = "Overloading not allowed"; 
          error_message(error_msg,flag);//no overloading
        }
        current_method = function_name;
        function_object = new FunctionTable();
        argument_index = 0;
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        n.f5.accept(this, argu);
        n.f6.accept(this, argu);
        n.f7.accept(this, argu);
        n.f8.accept(this, argu);
        n.f9.accept(this, argu);
        n.f10.accept(this, argu);
        n.f11.accept(this, argu);
        n.f12.accept(this, argu);
        function_object.return_type = return_type;
        class_object.functions.put(function_name,function_object);//since it's by reference, this is safe. Safer is to update each time
        current_method = null;
      }
      else
      {
        //now typecheck for return statement or undeclared variables etc
        n.f0.accept(this,argu);
        String return_type = (String)n.f1.accept(this,argu);
        current_method = (String)n.f2.accept(this,argu);
        function_object = class_object.functions.get(current_method);
        check_function();
        //System.out.println("Function object of function"  + current_method + "is " + function_object);
        n.f3.accept(this,argu);
        n.f4.accept(this,argu);
        n.f5.accept(this,argu);
        n.f6.accept(this,argu);
        n.f7.accept(this,argu);
        n.f8.accept(this,argu);
        n.f9.accept(this,argu);
        String rt = (String)n.f10.accept(this,argu);
        if(!type_check(return_type,rt))//can type2 be typecast into type1?
        {
          String error_msg = "Type error"; 
          String flag = "Function return type does not match that of return statement"; 
          error_message(error_msg,flag);
        }
        n.f11.accept(this,argu);
        n.f12.accept(this,argu);
        current_method = null;
      }
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
      R _ret=null;//always visit irrespective of what the pass is.
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) {
      R _ret=null;
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)
      {
        String arg_type = (String)n.f0.accept(this, argu);
        String name = (String)n.f1.accept(this, argu);
        if(function_object.arguments.get(name) != null)
        {
          String error_msg = "Type error"; 
          String flag = "Redeclaration of function parameter"; 
          error_message(error_msg,flag);
        }
        function_object.arguments.put(name,arg_type);
        function_object.type_inorder.put(argument_index,arg_type);
        argument_index++;
      }
      else
      { 
        String arg_type = (String)n.f0.accept(this,argu);
        String name = (String)n.f1.accept(this,argu);
        if(arg_type.equals("int") || arg_type.equals("boolean") || arg_type.equals("int[]") || (classes.get(arg_type) != null))
        {
          return _ret;
        }
        else
        {
          String error_msg = "Symbol not found"; 
          String flag = "Undefined type for function argument"; 
          error_message(error_msg,flag);
        }
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {
      R _ret = (R)"int[]";
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      R _ret = (R)"boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) {
      R _ret = (R)"int";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)
      {
        //System.out.println("Hii " + current_class + ":" + current_method);
      }
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0)
      {
        //System.out.println("Hii block" + current_class + ":" + current_method);
      }
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      R _ret=null;
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0){
        //check for well defined variable now
        String id = (String)n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        String type_expr = (String)n.f2.accept(this, argu);
        n.f3.accept(this, argu);
      }
      else{
        String id = (String)n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        String type_expr = (String)n.f2.accept(this, argu);
        n.f3.accept(this, argu);
        if(!((function_object.arguments.get(id) != null) || (function_object.variables.get(id) != null) || (check_parent(id))))
        {
          String error_msg = "Symbol not found"; 
          String flag = "AssignmentStatement Variable undeclared"; 
          error_message(error_msg,flag);   
        }
        //System.out.println(id + " " + type_expr);
        if(type_check(id,type_expr))
        {
          return _ret;
        }
        else
        {
          String error_msg = "Type error"; 
          String flag = "AssignmentStatement Type Mismatch " + id + ":" + get_type(id) + "," + get_type(type_expr); 
          error_message(error_msg,flag);
        }
      }
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      R _ret=null;
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0){
        String id = (String)n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        String exp1 = (String)n.f2.accept(this, argu);
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        String exp2 = (String)n.f5.accept(this, argu);
        n.f6.accept(this, argu);
      }
      else{
        //now type check
        String id = (String)n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        String exp1 = (String)n.f2.accept(this, argu);
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        String exp2 = (String)n.f5.accept(this, argu);
        n.f6.accept(this, argu);
        if(!((function_object.arguments.get(id) != null) || (function_object.variables.get(id) != null) || (check_parent(id))))
        {
          String error_msg = "Symbol not found"; 
          String flag = "ArrayAssignmentStatement variable not found"; 
          error_message(error_msg,flag);  
        }
        if(get_type(id).equals("int[]") && get_type(exp1).equals("int") && get_type(exp2).equals("int"))
          return _ret;
        else
        {
          String error_msg = "Type error"; 
          String flag = "ArrayAssignmentStatement Type Mismatch"; 
          error_message(error_msg,flag);
        }
      }
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      //System.out.println("Hello!");
      String x = (String)n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        if(!x.equals("boolean"))
        {
          String error_msg = "Type error"; 
          String flag = "IfStatement expression Type mismatch"; 
          error_message(error_msg,flag);
        }
        return _ret;  
      }
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      //System.out.println("Hello! 1");
      String x = (String)n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      //System.out.println("Hello! 2");
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      //System.out.println("Hello! 3");
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        if(!x.equals("boolean"))
        {
          String error_msg = "Type error"; 
          String flag = "IfthenElseStatement Expression Type mismatch"; 
          error_message(error_msg,flag);
        }
        return _ret;  
      }
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String x = (String)n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        if(!x.equals("boolean"))
        {
          String error_msg = "Type error"; 
          String flag = "WhileStatement Expression Type Mismatch"; 
          error_message(error_msg,flag);
        }
        else
          return null;
      }
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String x = (String)n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
      	x = get_type(x);
        if(!x.equals("int"))
        {
          String error_msg = "Type error"; 
          String flag = "Print statement Type is not int"; 
          error_message(error_msg,flag);
        }
      }
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;//type of the expression
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) {
      R _ret=null;
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        y = get_type(y);
        if(!x.equals("boolean") || !y.equals("boolean"))
        {
          String error_msg = "Type error"; 
          String flag = "AndExpression Type mismatch"; 
          error_message(error_msg,flag);
        }
        //System.out.println("AND is okay");
        return (R)"boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) {
      R _ret=null;
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        y = get_type(y);
        if(!x.equals("boolean") || !y.equals("boolean"))
        {
          String error_msg = "Type error"; 
          String flag = "OrExpression Type Mismatch"; 
          error_message(error_msg,flag);
        }
        return (R)"boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) {
      R _ret=null;
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        y = get_type(y);
        if(!x.equals("int") || !y.equals("int"))
        {
          String error_msg = "Type error"; 
          String flag = "CompareExpression Type Mismatch"; 
          error_message(error_msg,flag);
        }
        //System.out.println("<= is Okay");
        return (R)"boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) {
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)//second pass is when types will have been deduced.
      {
        x = get_type(x);
        y = get_type(y);
        boolean x1 = (x.equals("int") || x.equals("boolean"));
        boolean x2 = (y.equals("int") || y.equals("boolean"));
        if(x1 != x2)
        {
          String error_msg = "Type error"; 
          String flag = "Primtive vs Non primtive for !="; 
          error_message(error_msg,flag);
        }
        boolean x3 = x.contains("[]");
        boolean x4 = y.contains("[]");
        if(x3 != x4)
        {
          String error_msg = "Type error"; 
          String flag = "Array type versus primitive/object comparison for !="; 
          error_message(error_msg,flag);
        }
        else if(x3 == true)
        {
          return (R)"boolean";
        }
        if(x1 == true)
        {
          if(!x.equals(y))
          {
            String error_msg = "Type error"; 
            String flag = "Int versus boolean fails for !="; 
            error_message(error_msg,flag);
          }
          return (R)"boolean";
        }
        else
        {
          return (R)"boolean";//two object types can be compared by address directly
        }
      }
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n, A argu) {
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)//type check only now after building class tables etc
      {
        x = get_type(x);
        y = get_type(y);
        if((!x.equals("int")) || (!y.equals("int")))
        {
          String error_msg = "Type error"; 
          String flag = "PlusExpression Type Mismatch"; 
          error_message(error_msg,flag);
        }
      }
      return (R)"int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) {
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        y = get_type(y);
        if((!x.equals("int")) || (!y.equals("int")))
        {
          String error_msg = "Type error"; 
          String flag = "MinusExpression Type Mismatch"; 
          error_message(error_msg,flag);
        }
      }
      return (R)"int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) {
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        y = get_type(y);
        if((!x.equals("int")) || (!y.equals("int")))
        {
          String error_msg = "Type error"; 
          String flag = "TimesExpression Type Mismatch"; 
          error_message(error_msg,flag);
        }
      }
      return (R)"int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) {
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        y = get_type(y);
        if((!x.equals("int")) || (!y.equals("int")))
        {
          String error_msg = "Type error"; 
          String flag = "DivExpression Type Mismatch"; 
          error_message(error_msg,flag);
        }
      }
      return (R)"int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      R _ret=null;
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String y = (String)n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        x = get_type(x);
        y = get_type(y);
        if((!x.equals("int[]")) || (!y.equals("int")))
        {
          String error_msg = "Type error"; 
          String flag = "ArrayLookup Type Mismatch"; 
          error_message(error_msg,flag);        
        }
      }
      return (R)"int";//returns the type of the array object
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      R _ret=null;
      String t = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        t = get_type(t);
        if(!t.equals("int[]"))
        {
          String error_msg = "Type error"; 
          String flag = "ArrayLength Type Mismatch"; 
          error_message(error_msg,flag);
        }
      }
      _ret = (R)"int";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) {
      R _ret=null;
      //primary expression should be of type object
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 0){
        n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        n.f5.accept(this, argu);
      }
      else
      {
        //now proceed to typecheck
        int old_size = message_arguments.size();
        String obj = (String)n.f0.accept(this,argu);
        String nm = obj;
        n.f1.accept(this,argu);
        String id = (String)n.f2.accept(this,argu);
        n.f3.accept(this,argu);
        //System.out.println(function_object + " " + class_object);
        obj = get_type(obj);
        if(obj.equals("int") || obj.equals("boolean") || obj.equals("int[]"))
        {
          String error_msg = "Type error"; 
          String flag = "Primtives cannot issue message send requests"; 
          error_message(error_msg,flag); 
        }
        if(obj.equals("void"))
        {
          String error_msg = "Symbol not found"; 
          String flag = "Message argument symbol does not exist"; 
          error_message(error_msg,flag);
        }
        n.f4.accept(this,argu);
        n.f5.accept(this,argu);
        //System.out.println(nm + " of type " + obj + " is trying to call " + id);
        int num_args = message_arguments.size() - old_size;
        String back_active = this_class;
        this_class = obj;//we are inside this object class right now technically when we look for function calls alone
        String an = get_function(id,num_args,old_size);//search the current class/parents/parents of parents etc for signature match
        if(an == null)
        {
          String error_msg = "Symbol not found"; 
          String flag = "No function exists with the given name." + id;
          // for(int i = 0;i < num_args;i++)
          // {
          //   System.out.println(message_arguments.get(old_size+i));
          // } 
          error_message(error_msg,flag);
        }
        while(message_arguments.size() != old_size)
        {
          message_arguments.remove(message_arguments.size()-1);
        }
        this_class = back_active;
        return (R)an;
      }
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
      R _ret=null;
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        message_arguments.add(get_type(x));
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String x = (String)n.f1.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        message_arguments.add(get_type(x));
      }
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;//type of the expression
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret= (R)"int";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      R _ret=(R)"boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) {
      R _ret=(R)"boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      Integer argument = (Integer)argu;
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) {
      R _ret = (R)"this";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String x = (String)n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      Integer argument = (Integer)argu;
      if(!x.equals("int"))
      {
        String error_msg = "Type error"; 
        String flag = "ArrayAllocationExpression Type Mismatch"; 
        error_message(error_msg,flag);
      }
      if(Integer.valueOf(argument) == 1)
        return (R)"int[]";//must evaluate to int[] as a type
      else
        return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String x = (String)n.f1.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        if(!x.equals("boolean"))
        {
          String error_msg = "Type error"; 
          String flag = "NotExpression Type Mismatch"; 
          error_message(error_msg,flag);
        }
      }
      return (R)"boolean";
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   //function call params
   public R visit(IdentifierList n, A argu) {
      R _ret=null;
      String x = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        message_arguments.add(x);
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public R visit(IdentifierRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String x = (String)n.f1.accept(this, argu);
      Integer argument = (Integer)argu;
      if(Integer.valueOf(argument) == 1)
      {
        message_arguments.add(x);
      }
      return _ret;
   }
}
