//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

import javax.lang.model.util.ElementScanner6;

import jdk.nashorn.internal.IntDeque;

import java.io.PrintWriter;
/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
class LiveNode
{

	public Hashtable<String,Boolean> use;
	public Hashtable<String,Boolean> def;
	public Hashtable<LiveNode,Boolean> succ;
	public Hashtable<String,Boolean> in;
	public Hashtable<String,Boolean> out;
	LiveNode()
	{
		use = new Hashtable<String,Boolean>();
		def = new Hashtable<String,Boolean>();
		succ = new Hashtable<LiveNode,Boolean>();
		in = new Hashtable<String,Boolean>();
		out = new Hashtable<String,Boolean>();
	}
}

class FunctionValues
{
  int arguments;
  int stack_slots;
  int max_calls;
  int spill_val_beg;
  boolean spilled;
  FunctionValues()
  {
    arguments = stack_slots = max_calls = spill_val_beg = 0;
    spilled = false;
  }
}

public class myDFS<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
  //We need one more pass for function argument counting and for maximum number of calls that are made.
	LiveNode curr_node = null;
  int node_count = 0;
  String current_function = null;
  PrintWriter pw = new PrintWriter(System.out,true);
	Hashtable<String,LiveNode> NodeIndex = new Hashtable<String,LiveNode>();//hash of label names to node values
  Hashtable<String,Boolean> registers_used = new Hashtable<String,Boolean>();
  Hashtable<String,Hashtable<String,String>> allocated_register = new Hashtable<String,Hashtable<String,String>>();
	Hashtable<String,ArrayList<LiveNode>> requests_pending = new Hashtable<String,ArrayList<LiveNode>>();
	Hashtable<String,Pair<Integer,Integer>> live_range = new Hashtable<String,Pair<Integer,Integer>>();
  ArrayList<LiveNode> nodes = new ArrayList<LiveNode>();
  ArrayList<Pair<Integer,Integer>> live = new ArrayList<Pair<Integer,Integer>>();
    TreeMap<Pair<Integer,Integer>,Integer> active = new TreeMap<Pair<Integer,Integer>,Integer>(new Comparator<Pair<Integer,Integer>>() {
      public int compare(Pair<Integer,Integer> p1,Pair<Integer,Integer> p2)
      {
        if(p1.second > p2.second)
          return 1;
        else if(p1.second < p2.second)
          return -1;
        else
        {
          if(p1.first < p2.first)
            return -1;
          else if(p1.first > p2.first)
            return 1;
          else
            return 0;//values are equal,used for removing upon finding the element!
        }
      }
    });
  Hashtable<String,Pair<Integer,Integer>> ranges = new Hashtable<String,Pair<Integer,Integer>>();//register to interval
  Hashtable<Pair<Integer,Integer>,String> register_allocated = new Hashtable<Pair<Integer,Integer>,String>();
  TreeMap<String,Boolean> free_pool = new TreeMap<String,Boolean>();
  int spill_arg = 0;//first available location
  Hashtable<String,FunctionValues> function_data = new Hashtable<String,FunctionValues>();
  Hashtable<String,Boolean> spilled_counter = new Hashtable<String,Boolean>();
  int max_args = 0;
  int arg_counter = 0;
  int caller_saved = 10;
  int callee_saved = 8;
  boolean called_a_fn = false;
  String get_allocated_register(String t)
  {
    return ((allocated_register.get(current_function)).get(t));
  }
  public void print_nodes()
  {
    int i;
    for(i = 0;i < nodes.size();i++)
    {
      LiveNode n = nodes.get(i);
      pw.printf("For Node #%d:\n",i);
      pw.print("Use: ");
      Iterator<String> it = n.use.keySet().iterator();
      while(it.hasNext())
      {
        pw.printf("%s ",it.next());
      }
      it = n.def.keySet().iterator();
      pw.printf("\nDef: ");
      while(it.hasNext())
      {
        pw.printf("%s ",it.next());
      }
      pw.printf("\n%d Successor Nodes\n",n.succ.size());
    }
  }
  public void print_live_ranges()
  {
    Iterator<String> it = ranges.keySet().iterator();
    while(it.hasNext())
    {
      String y = it.next();
      Pair<Integer,Integer> p = ranges.get(y);
      String r_al = register_allocated.get(p);
      pw.printf("%s has a live range of %d to %d and is allocated %s\n",y,p.first,p.second,r_al);
    }
  }

  boolean equal(Hashtable<String,Boolean> a,Hashtable<String,Boolean> b)
  {
    if(a.size() != b.size())
      return false;
    Iterator<String> it1 = a.keySet().iterator();
    while(it1.hasNext())
    {
      String n = it1.next();
      if(b.get(n) == null)
        return false;
    }
    return true;
  }
  public void build_liveliness()
  {
    int cnt = 0;
    while(true)
    {
      cnt++;
      //pw.printf("Iteration %d of the liveness analysis\n",cnt);
      boolean flag = true;
      int i;
      for(i = nodes.size()-1;i >= 0;i--)//reverse order 
      {
        Hashtable<String,Boolean> h1 = new Hashtable<String,Boolean>();
        Hashtable<String,Boolean> h2 = new Hashtable<String,Boolean>();
        LiveNode n = nodes.get(i);
        Iterator<String> it1 = n.in.keySet().iterator();
        while(it1.hasNext())
          h1.put(it1.next(),true);
        it1 = n.out.keySet().iterator();
        while(it1.hasNext())
          h2.put(it1.next(),true);
        n.in.clear();
        it1 = n.use.keySet().iterator();
        while(it1.hasNext())
        {
          n.in.put(it1.next(),true);
        }
        it1 = n.out.keySet().iterator();
        while(it1.hasNext())
        {
          String t = it1.next();
          if(n.def.get(t) == null)
            n.in.put(t,true);
        }
        n.out.clear();
        Iterator<LiveNode> it = n.succ.keySet().iterator();
        while(it.hasNext())
        {
          Iterator<String> it2 = it.next().in.keySet().iterator();
          while(it2.hasNext())
          {
            n.out.put(it2.next(),true);
          }
        }
        flag = flag && equal(h1,n.in);
        flag = flag && equal(h2,n.out);
      }
      if(flag)
        break;//iterative liveness has been built sucessfully
    }
    //pw.printf("Converged after %d iterations\n",cnt);
  }
	public void build_live_ranges()
	{
    ranges.clear();
		Hashtable<String,Integer> mi = new Hashtable<String,Integer>();
    Hashtable<String,Integer> ma = new Hashtable<String,Integer>();
    int i;
    for(i = 0;i < nodes.size();i++)
    {
      LiveNode n = nodes.get(i);
      Iterator<String> it1 = n.in.keySet().iterator();
      while(it1.hasNext())
      {
        String x = it1.next();
        if(ma.get(x) == null)
          ma.put(x,i);
        else
        {
          ma.put(x,Math.max(ma.get(x),i));
        }
      }
      it1 = n.def.keySet().iterator();
      while(it1.hasNext())
      {
        String x = it1.next();
        if(mi.get(x) == null)
          mi.put(x,i);
        else
        {
          mi.put(x,Math.min(mi.get(x),i));
        }
        if(ma.get(x) == null)
          ma.put(x,i);
        else
          ma.put(x,Math.max(ma.get(x),i));
      }
    }
    Iterator<String> it = mi.keySet().iterator();
    while(it.hasNext())
    {
      String s = it.next();
      int x,y;
      ranges.put(s,new Pair<Integer,Integer>(mi.get(s),ma.get(s)));
    } 
  }
  void expire_old_intervals(Pair<Integer,Integer> i)
  {
    ArrayList<Pair<Integer,Integer>> a = new ArrayList<Pair<Integer,Integer>>();
    Iterator<Pair<Integer,Integer>> it = active.keySet().iterator();
    while(it.hasNext())
    {
      Pair<Integer,Integer> p = it.next();
      if(p.second >= i.first)
        break;
      a.add(p);
    }
    while(a.size() != 0)
    {
      Pair<Integer,Integer> p = a.get(a.size()-1);
      int x = active.get(p);
      if(x == 1)
        active.remove(p);
      else
        active.put(p,x-1);
      free_pool.put(register_allocated.get(p),true);
      a.remove(a.size()-1);
    }
  }
  void spill_at_interval(Pair<Integer,Integer> p)
  {
    Pair<Integer,Integer> spill = active.lastKey();
    if(spill.second > p.second)
    {
      register_allocated.put(p,register_allocated.get(spill));
      register_allocated.put(spill,String.format("SPILLEDARG %d",spill_arg));
      spill_arg++;
      int x = active.get(spill);
      if(x == 1)
        active.remove(spill);
      else
        active.put(spill,x-1);
      if(active.containsKey(p))
      {
        int y = active.get(p);
        active.put(p,y+1);
      }
      else
      {
        active.put(p,1);
      }
    }
    else
    {
      register_allocated.put(p,String.format("SPILLEDARG %d",spill_arg));
      spill_arg++;//new stack location for the spilled value
    }
  }
  public void assign_registers(int n_args)
  {
    int i;
    active.clear();
    live.clear();
    free_pool.clear();
    register_allocated.clear();
    spill_arg = Math.max(0,n_args-4);//each register saves the spilled args separately
    for(i = 0;i <= 7;i++)
    {
      free_pool.put("s" + Integer.toString(i),true);
    }
    for(i = 0;i <= 9;i++)
    {
      free_pool.put("t" + Integer.toString(i),true);
    }
    Iterator<String> it = ranges.keySet().iterator();
    while(it.hasNext())
    {
      String x = it.next();
      Pair<Integer,Integer> p = ranges.get(x);
      live.add(p);//add all intervals by references themselves
    }
    Collections.sort(live,new Comparator<Pair<Integer,Integer>>(){
      public int compare(Pair<Integer,Integer> p1,Pair<Integer,Integer> p2)
      {
        if(p1.first < p2.first)
          return -1;
        else if(p1.first > p2.first)
          return 1;
        else
        {
          if(p1.second > p2.second)
            return 1;
          else if(p1.second < p2.second)
            return -1;
          else
            return 0;
        }
      }
    });
    for(Pair<Integer,Integer> p: live)
    {
      expire_old_intervals(p);
      if(free_pool.size() == 0)
        spill_at_interval(p);
      else
      {
        String al = free_pool.firstKey();
        register_allocated.put(p,al);
        free_pool.remove(al);
        if(active.containsKey(p))
        {
          int x = active.get(p);
          active.put(p,x+1);
        }
        else
        {
          active.put(p,1);
        }
      }
    }
    Hashtable<String,String> h = new Hashtable<String,String>();
     it = ranges.keySet().iterator();
     while(it.hasNext())
     {
        String y = it.next();
        // pw.printf("Putting %s within %s\n",y,current_function);
        h.put(y,register_allocated.get(ranges.get(y)));
     }
     allocated_register.put(current_function,h);
    //pw.printf("For function %s\n",current_function);
    //print_live_ranges();
  }
	void update_used(LiveNode n,String reg)
	{
		if(registers_used.get(reg) == null)
		{
			registers_used.put(reg,true);
			n.def.put(reg,true);
		}
		else
    {
      if(n.def.get(reg) == null)
			 n.use.put(reg,true);
    }
	}
  void update_curr(LiveNode n)
  {
    nodes.add(n);
    node_count++;
    if(curr_node == null)
    {
      curr_node = n;
      return;
    }
    curr_node.succ.put(n,true);
    curr_node = n;
    return;
  }
	void update_succ(LiveNode n,String y)
	{
		if(n == null)
			return;
		if(NodeIndex.get(y) == null)
	      {
	      	if(requests_pending.get(y) == null)
	      	{
	      		requests_pending.put(y,new ArrayList<LiveNode>());
	      	}
	      	requests_pending.get(y).add(n);//will be resolved later
	      }
	      else
	      {
	      	LiveNode n1 = NodeIndex.get(y);
	      	n.succ.put(n1,true);
	      }
	} 
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a == 2)//code generation
      {
        //callee saved registers have to be maintained
        int i;
        n.f0.accept(this,argu);
        current_function = "MAIN";
        FunctionValues fn = function_data.get("MAIN");
        spill_arg = fn.spill_val_beg;
        int ov = spill_arg;
        pw.printf("MAIN [%d] [%d] [%d]\n",fn.arguments,fn.stack_slots,fn.max_calls);
        for(i = 0;i <= 7;i++)
        {
          pw.printf("ASTORE SPILLEDARG %d s%d\n",spill_arg,i);
          spill_arg++;
        }
        int ov1 = spill_arg;
        n.f1.accept(this,argu);
        n.f2.accept(this,argu);
        spill_arg = ov1-1;
        String spill_info = (fn.spilled)?"SPILLED":"NOTSPILLED";
        for(i = 7;i >= 0;i--)
        {
          pw.printf("ALOAD s%d SPILLEDARG %d\n",i,spill_arg);//callee saved registers
          spill_arg--;
        }
        spill_arg = ov;
        pw.printf("END\n//%s\n",spill_info);
        n.f3.accept(this,argu);
        n.f4.accept(this,argu);
      }
      else if(a == 1)
      {
        spilled_counter.clear();
        max_args = 0;
        current_function = "MAIN";
        called_a_fn = false;
        n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        FunctionValues fn = new FunctionValues();
        fn.arguments = 0;
        fn.stack_slots = spilled_counter.size() + ((called_a_fn)?caller_saved:0) + callee_saved + Math.max(0,max_args-4);//always save the callee saved registers
        fn.max_calls = max_args;
        fn.spilled = (spilled_counter.size() > 0);
        fn.spill_val_beg = spilled_counter.size() + Math.max(fn.arguments-4,0);//allocation for extra frame values can begin from here.
        function_data.put("MAIN",fn);//add the data to the table
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
      }
      else if(a == 0)
      {
        curr_node = null;//begin liveness analysis again
        nodes.clear();
        current_function = "MAIN";
        n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        build_liveliness();
        build_live_ranges();
        assign_registers(0);
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if((a == 0) || (a == 1) || (a == 2))
      {
      	n.f0.accept(this,argu);
      }
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) 
   {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
        current_function = (String)n.f0.accept(this, (A)new Integer(-1));
        nodes.clear();
        registers_used.clear();
	      n.f1.accept(this, argu);
        String arg = (String)n.f2.accept(this, argu);
        int n_args = Integer.parseInt(arg);
        curr_node = new LiveNode();
        nodes.add(curr_node);
        int y = Integer.parseInt(arg);
        int i;
        for(i = 0;i < y;i++)
        {
          update_used(curr_node,Integer.toString(i));//ghost node having all defs of values used as args
        }
	      n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        build_liveliness();
        build_live_ranges();
        assign_registers(n_args);
	    }
      else if(a == 1)//second pass to build function values
      {
        spilled_counter.clear();
        max_args = 0;
        current_function = (String)n.f0.accept(this, argu);
        called_a_fn = false;
        n.f1.accept(this, argu);
        String y = (String)n.f2.accept(this, argu);
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        FunctionValues fn = new FunctionValues();
        fn.arguments = Integer.parseInt(y);
        fn.stack_slots = Math.max(fn.arguments-4,0) + spilled_counter.size() + ((called_a_fn)?caller_saved:0) + callee_saved + Math.max(max_args-4,0);//always save the callee saved registers
        fn.max_calls = max_args;
        fn.spilled = (spilled_counter.size() > 0);
        fn.spill_val_beg = spilled_counter.size() + Math.max(fn.arguments-4,0);//allocation for extra frame values can begin from here.
        //pw.printf("Function %s has params %d %d %d\n",x,fn.arguments,fn.stack_slots,fn.max_calls);
        //pw.println(spilled_counter.size());
        function_data.put(current_function,fn);//add the data to the table
      }
      else if(a == 2)
      {
        current_function = (String)n.f0.accept(this,(A)new Integer(1));
        FunctionValues fn = function_data.get(current_function);
        n.f1.accept(this,argu);
        n.f2.accept(this,(A)new Integer(1));
        n.f3.accept(this,argu);
        pw.printf("%s [%d] [%d] [%d]\n",current_function,fn.arguments,fn.stack_slots,fn.max_calls);
        spill_arg = fn.spill_val_beg;
        int ov = spill_arg;
        int i;
        for(i = 0;i <= 7;i++)
        {
          pw.printf("ASTORE SPILLEDARG %d s%d\n",spill_arg,i);
          spill_arg++;
        }
        for(i = 0;i <= Math.min(3,fn.arguments-1);i++)
        {
          String ra = get_allocated_register(Integer.toString(i));
          if(ra.charAt(0) == 'S')
            pw.printf("ASTORE %s a%d\n",ra,i);
          else
            pw.printf("MOVE %s a%d\n",ra,i);
        }
        int l = 0;
        for(i = 4;i <= fn.arguments-1; i++)
        {
          String ra = get_allocated_register((Integer.toString(i)));
          pw.printf("ALOAD v0 SPILLEDARG %d\n",l);
          if(ra.charAt(0) == 'S')
            pw.printf("ASTORE %s v0\n",ra);
          else
            pw.printf("MOVE %s v0\n",ra);
          l++;//arguments from the stack frame
        }
        int ov1 = spill_arg;
        n.f4.accept(this,argu);
        spill_arg = ov1-1;
        for(i = 7;i >= 0;i--)
        {
          pw.printf("ALOAD s%d SPILLEDARG %d\n",i,spill_arg);
          spill_arg--;
        }
        spill_arg = ov;
        String spill_status = (fn.spilled)?"SPILLED":"NOTSPILLED";
        pw.printf("END\n//%s\n",spill_status);//end of each procedure
      }
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) 
   {
      R _ret=null;
      int a = Integer.valueOf((Integer)(argu));
      if(a == 0)
      {
      	n.f0.accept(this, argu);
      }
      else if(a == 1)
        n.f0.accept(this,argu);
      else if(a == 2)
        n.f0.accept(this,argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) 
   {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if(a == 2)
        pw.printf("NOOP\n");
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if(a == 2)
        pw.printf("ERROR\n");
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      Integer a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
        n.f0.accept(this, argu);
        LiveNode n1 = new LiveNode();
        update_curr(n1);
	      String x = (String)n.f1.accept(this, (A)new Integer(-1));
	      String y = (String)n.f2.accept(this, (A)new Integer(-1));//will be covered as a successor node later on
	      update_succ(curr_node,y);
     }
     else if(a == 1)
     {
      n.f0.accept(this,argu);
      n.f1.accept(this,argu);
      n.f2.accept(this,argu);
     }
     else if(a == 2)
     {
       n.f0.accept(this,argu);
       String x = (String)n.f1.accept(this,(A)new Integer(0));
       String y = (String)n.f2.accept(this,(A)new Integer(1));
       String ra = get_allocated_register(x);
       if(ra.charAt(0) == 'S')
       {//load a spilled argument from memory
         pw.printf("ALOAD v0 %s\n",ra);
         pw.printf("CJUMP v0 %s\n",y);
       }
       else
       {
         pw.printf("CJUMP %s %s\n",ra,y);
       }
     }
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
      	n.f0.accept(this, argu);
        LiveNode n1 = new LiveNode();
        update_curr(n1);
      	String x = (String)n.f1.accept(this,(A)new Integer(-1));//create a new label
        update_succ(curr_node,x);
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        String x = (String)n.f1.accept(this,(A)new Integer(1));
        pw.printf("JUMP %s\n",x);
      }
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
      	n.f0.accept(this, argu);
        LiveNode n1 = new LiveNode();
        update_curr(n1);
        Integer ar = new Integer(-1);
      	String x1 = (String)n.f1.accept(this, (A)ar);
        //update_used(curr_node,x1);
      	n.f2.accept(this, argu);
      	String x2 = (String)n.f3.accept(this, (A)ar);
        //update_used(curr_node,x2);
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
        n.f2.accept(this,argu);
        n.f3.accept(this,argu);
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        String x1 = (String)n.f1.accept(this,argu);
        String x2 = (String)n.f2.accept(this,(A)new Integer(1));
        String x3 = (String)n.f3.accept(this,argu);
        x1 = get_allocated_register(x1);
        x3 = get_allocated_register(x3);
        if(x1.charAt(0) == 'S')
        {
          pw.printf("ALOAD v0 %s\n",x1);
          x1 = "v0";
        }
        if(x3.charAt(0) == 'S')
        {
          pw.printf("ALOAD v1 %s\n",x3);
          x3 = "v1";
        }
        pw.printf("HSTORE %s %s %s\n",x1,x2,x3);
      }
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
	      n.f0.accept(this, argu);
        LiveNode n1 = new LiveNode();
        update_curr(n1);
        Integer ar = new Integer(-1);
	      n.f1.accept(this, (A)ar);
	      n.f2.accept(this, (A)ar);
        // update_used(curr_node,x);
        // update_used(curr_node,y);
	      n.f3.accept(this, argu);
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
        n.f2.accept(this,argu);
        n.f3.accept(this,argu);
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        String x1 = (String)n.f1.accept(this,argu);
        String x2 = (String)n.f2.accept(this,argu);
        String x3 = (String)n.f3.accept(this,(A)new Integer(1));
        x1 = get_allocated_register(x1);
        x2 = get_allocated_register(x2);
        if(x1.charAt(0) == 'S')
        {
          pw.printf("ALOAD v0 %s\n",x1);
          x1 = "v0";
        }
        if(x2.charAt(0) == 'S')
        {
          pw.printf("ALOAD v1 %s\n",x2);
          x2 = "v1";
        }
        pw.printf("HLOAD %s %s %s\n",x1,x2,x3);
      }
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
	      n.f0.accept(this, argu);
        LiveNode n1 = new LiveNode();
        update_curr(n1);
        Integer ar = new Integer(-1);
	      String x = (String)n.f1.accept(this,(A)ar);//don't re-alloc for labels here.
	      n.f2.accept(this, (A)ar);
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
        n.f2.accept(this,argu);
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        String x1 = (String)n.f1.accept(this,argu);//get the register that has been allocated here first
        x1 = get_allocated_register(x1);
        n.f2.accept(this,(A)new Integer(3));//put it into the register v0,add this functionslity everywhere else
        if(x1.charAt(0) == 'S')
          pw.printf("ASTORE %s v0\n",x1);//exp is always returned in v0 as per assumption
        else
          pw.printf("MOVE %s v0\n",x1);
      }
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) 
   {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
        LiveNode n1 = new LiveNode();
        update_curr(n1);
      	n.f0.accept(this, argu);
      	n.f1.accept(this, (A)new Integer(-1));
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        String x = (String)n.f1.accept(this,(A)new Integer(3));//temp has to return the register value itself
        pw.printf("PRINT %s\n",x);
      }
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a <= 0)
      {
      	n.f0.accept(this, (A)new Integer(-1));
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
      }
      else if(a == 2)
        n.f0.accept(this,argu);
      else if(a == 3)
        n.f0.accept(this,argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      int a  = Integer.valueOf((Integer)argu);
      if(a == -1)
      {
        n.f0.accept(this, argu);
	      n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        LiveNode n1 = new LiveNode();
        update_curr(n1);
	      n.f3.accept(this,argu);//do not print the simple exp if we return a label by chance
	      n.f4.accept(this,argu);
      }
      else if(a == 0)
      {
	      n.f0.accept(this, argu);
	      n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        LiveNode n1 = new LiveNode();
        update_curr(n1);
	      n.f3.accept(this, (A)new Integer(-1));//do not print the simple exp if we return a label by chance
	      n.f4.accept(this, argu);
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
        n.f2.accept(this,argu);
        n.f3.accept(this,argu);
        n.f4.accept(this,argu);
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
        n.f2.accept(this,argu);
        String x = (String)n.f3.accept(this,(A)new Integer(3));
        if(!x.equals("v0"))
        {
          if(x.charAt(0) == 'S')
            pw.printf("ALOAD v0 %s\n",x);//return value is stored in v0
          else
            pw.printf("MOVE v0 %s\n",x);
        }
        n.f4.accept(this,argu);
      }
      else if(a == 3)
      {
        Integer narg = new Integer(2);
        n.f0.accept(this,(A)narg);
        n.f1.accept(this,(A)narg);
        n.f2.accept(this,argu);
        String x = (String)n.f3.accept(this,argu);
        if(!x.equals("v0"))
        {
          if(x.charAt(0) == 'S')
            pw.printf("ALOAD v0 %s\n",x);//return value is stored in v0
          else
            pw.printf("MOVE v0 %s\n",x);
        }
        n.f4.accept(this,argu);
      }
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a <= 0)
      {
        Integer a1 = new Integer(-1);
	      n.f0.accept(this, argu);
	      n.f1.accept(this, (A)a1);
	      n.f2.accept(this, argu);
	      n.f3.accept(this, (A)a1);
	      n.f4.accept(this, argu);
      }
      else if(a == 1)
      {
        called_a_fn = true;
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
        arg_counter = 0;
        n.f2.accept(this,argu);
        n.f3.accept(this,argu);
        max_args = Math.max(max_args,arg_counter);
        n.f4.accept(this,argu);
      }
      else if(a == 2)
      {
        //first save the registers from t0-t9 as they are caller saved
        int og = spill_arg;
        int i;
        for(i = 0;i <= 9;i++)
        {
          pw.printf("ASTORE SPILLEDARG %d t%d\n",spill_arg,i);
          spill_arg++;
        }
        n.f0.accept(this,argu);
        String function_name = (String)n.f1.accept(this,(A)new Integer(3));
        n.f2.accept(this,argu);
        arg_counter = 0;
        int ov = spill_arg;
        n.f3.accept(this,(A)new Integer(4));
        n.f4.accept(this,argu);
        pw.printf("CALL %s\n",function_name);//could be a register or a label name itself
        spill_arg = ov-1;
        for(i = 9;i >= 0;i--)
        {
          pw.printf("ALOAD t%d SPILLEDARG %d\n",i,spill_arg);
          spill_arg--;
        }
        spill_arg = og;//restore the stack pointer after calling.
       }
       else if(a == 3)
       {
        int og = spill_arg;
        int i;
        for(i = 0;i <= 9;i++)
        {
          pw.printf("ASTORE SPILLEDARG %d t%d\n",spill_arg,i);
          spill_arg++;
        }
        n.f0.accept(this,argu);
        String function_name = (String)n.f1.accept(this,argu);
        n.f2.accept(this,argu);
        arg_counter = 0;
        int ov = spill_arg;
        n.f3.accept(this,(A)new Integer(4));
        n.f4.accept(this,argu);
        pw.printf("CALL %s\n",function_name);//could be a register or a label name itself
        spill_arg = ov-1;
        for(i = 9;i >= 0;i--)
        {
          pw.printf("ALOAD t%d SPILLEDARG %d\n",i,spill_arg);
          spill_arg--;
        }
        spill_arg = og;//restore the stack pointer after calling.
       } 
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a <= 0)
      {
      	n.f0.accept(this, argu);
      	n.f1.accept(this, (A)new Integer(-1));
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        String x = (String)n.f1.accept(this,(A)new Integer(3));
        pw.printf("MOVE v0 HALLOCATE %s\n",x);//value is always in v0/appropriate label name
      }
      else if(a == 3)
      {
        n.f0.accept(this,argu);
        String x = (String)n.f1.accept(this,argu);
        pw.printf("MOVE v0 HALLOCATE %s\n",x);//value is always in v0/appropriate label name
      }
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a <= 0)
      {
        Integer ar = new Integer(-1);
	      n.f0.accept(this, argu);
	      String a1 = (String)n.f1.accept(this, (A)ar);
	      String b1 = (String)n.f2.accept(this, (A)ar);
      }
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        n.f1.accept(this,argu);
        n.f2.accept(this,argu);
      }
      else if(a == 2)
      {
        String op = (String)n.f0.accept(this,argu);
        String r1 = (String)n.f1.accept(this,argu);
        String r2 = (String)n.f2.accept(this,(A)new Integer(3));//r2 would be either v0 or the register allocated
        r1 = get_allocated_register(r1);
        if(r1.charAt(0) == 'S')
        {
          pw.printf("ALOAD v1 %s\n",r1);
          r1 = "v1";
        }
        pw.printf("MOVE v0 %s %s %s\n",op,r1,r2);
      }
      else if(a == 3)
      {
        String op = (String)n.f0.accept(this,argu);
        String r1 = (String)n.f1.accept(this,(A)new Integer(2));
        String r2 = (String)n.f2.accept(this,(A)new Integer(3));//r2 would be either v0 or the register allocated
        r1 = get_allocated_register(r1);
        if(r1.charAt(0) == 'S')
        {
          pw.printf("ALOAD v1 %s\n",r1);
          r1 = "v1";
        }
        pw.printf("MOVE v0 %s %s %s\n",op,r1,r2);
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) 
   {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) 
   {
   	  int a = Integer.valueOf((Integer)argu);
      R _ret=null;
      if(a == -1)
      {
        n.f0.accept(this, argu);
        String x = (String)n.f1.accept(this, argu);
        update_used(curr_node,x);
        return (R)x;
      }

      else if(a == 0)
      {
      	n.f0.accept(this, argu);
      	String x = (String)n.f1.accept(this, argu);
      	return (R)x;
      }
      
      else if(a == 1)
      {
        n.f0.accept(this,argu);
        String y = (String)n.f1.accept(this,argu);
        String z = get_allocated_register(y);
        //pw.printf("%s in %s\n",z,current_function);
        if(z.charAt(0) == 'S')//spilled argument for the current function
          spilled_counter.put(y,true);
        arg_counter++;
      }
      else if(a == 2)
      {
        n.f0.accept(this,argu);
        _ret = n.f1.accept(this,(A)new Integer(1));
      }
      else if(a == 3)
      {
        n.f0.accept(this,argu);
        String x = (String)n.f1.accept(this,(A)new Integer(1));
        x = get_allocated_register(x);
        if(x.charAt(0) == 'S')
          pw.printf("ALOAD v0 %s\n",x);
        else
          pw.printf("MOVE v0 %s\n",x);
        return (R)"v0";
      }
      else if(a == 4)
      {
        //function argument
        n.f0.accept(this,argu);
        String x = (String)n.f1.accept(this,(A)new Integer(1));
        x = get_allocated_register(x);
        if(arg_counter <= 3)
        {
          if(x.charAt(0) == 'S')
            pw.printf("ALOAD a%d %s\n",arg_counter,x);
          else
            pw.printf("MOVE a%d %s\n",arg_counter,x);
          arg_counter++;
        }
        else
        {
          if(x.charAt(0) == 'S')
          {
            pw.printf("ALOAD v0 %s\n",x);
            x = "v0";
          }
          pw.printf("PASSARG %d %s\n",(arg_counter-3),x);//passarg is one ahead of stack args
          spill_arg++;
          arg_counter++;
        }
        return (R)x;
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if(a <= 1)
        _ret = n.f0.accept(this, argu);
      else
      {
        _ret = n.f0.accept(this,argu);
        pw.printf("MOVE v0 %s\n",(String)_ret);
        _ret = (R)"v0";
      }
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      int a = Integer.valueOf((Integer)argu);
      if((a == -1) || (a == 1))
      {
        _ret = n.f0.accept(this,argu);//do not create a label as of now,simply return it
      }
      else if(a == 0)
      {
      	String x = (String)n.f0.accept(this, argu);
        LiveNode n1 = new LiveNode();
      	update_curr(n1);
        NodeIndex.put(x,n1);
      	ArrayList<LiveNode> a1 = requests_pending.get(x);
      	int i;
        if(a1 != null)
        {
      	 for(i = 0;i < a1.size();i++)
      	 {
      		  LiveNode p = a1.get(i);
      		  p.succ.put(n1,true);
      	 }
      	 a1.clear();
      	 requests_pending.put(x,a1);
        }
      	return (R)x;
      }
      else if(a == 2)
      {
        //code generation
        String lname = (String)n.f0.accept(this,argu);
        pw.println(lname);//label name must be printed as part of statement list.
        _ret = (R)lname; 
      }
      else if(a == 3)
      {
        String lname = (String)n.f0.accept(this,argu);
        pw.printf("MOVE v0 %s\n",lname);
        return (R)"v0";
      }
      return _ret;
   }
}
